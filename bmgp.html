<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BMGP</title>
</head>
<body>
  <canvas
    id="gobang"
    width="500"
    height="500"
    style="
      padding: 0;
      margin: auto;
      display: block;
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;">
  </canvas>
  <script>
    // Init board canvas
    const canvas = document.getElementById('gobang');
    const ctx = canvas.getContext('2d');

    // Stone encodings
    const EMPTY = 0
    const BLACK = 1
    const WHITE = 2
    const MARKER = 4
    const OFFBOARD = 7
    const LIBERTY = 8

    // Go board
    var board = [];

    // 5x5 board, +2 is offboard
    var size = 7;

    // Side to move
    var side = BLACK;

    // Rendered cell size
    const cell = canvas.width / size;

    // Print position to console
    function printPosition() {
      let position = "";
      for (let sq = 0; sq < size ** 2; sq++) {
        position += (!(sq % size)) ? "\n" : "";
        position += board[sq] + " ";
      };console.log(position);
    }

    // Print board
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      for (let i = 1; i < size-1; i++) {
        const x = i * cell + cell / 2;
        const y = i * cell + cell / 2;
        let offset = cell * 2 - cell / 2;
        ctx.moveTo(offset, y);
        ctx.lineTo(canvas.width - offset, y);
        ctx.moveTo(x, offset);
        ctx.lineTo(x, canvas.height - offset);
      };ctx.stroke();
      for (let row = 0; row < size; row++) {
        for (let col = 0; col < size; col++) {
          let sq = row*size + col;
          if (board[sq] == 7) continue;
          let color = board[row * size + col] == 1 ? "black" : "white";
          if (board[sq]) {
            ctx.beginPath();
            ctx.arc(col * cell + cell / 2, row * cell + cell / 2, cell / 2 - 2, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.stroke();
          }
        }
      }
    }

    // Put stone on board
    function setStone(sq, color) {
      if (board[sq] == 0) {
        board[sq] = color;
        side = (side == BLACK) ? WHITE : BLACK;
        drawBoard();
        printPosition();
      }
    }

    // Handle mouse click event
    canvas.addEventListener('click', function (event) {
      let rect = canvas.getBoundingClientRect();
      let mouseX = event.clientX - rect.left;
      let mouseY = event.clientY - rect.top;
      let col = Math.floor(mouseX / cell);
      let row = Math.floor(mouseY / cell);
      let sq = row * size + col;
      setStone(sq, side);
    });

    // Init board
    function initBoard() {
      for (let sq = 0; sq < size ** 2; sq++) {
        switch (true) {
          case (sq < size):
          case (sq >= (size ** 2 - size)):
          case (!(sq % size)):
            board[sq] = OFFBOARD;
            board[sq-1] = OFFBOARD;
            break;
          default: board[sq] = 0;
        }
      }
    }

    // Handle captures
    function captures(color) {
      for (let sq = 0; sq < size ** 2; sq++) {
        let stone = board[square];
        if (stone == OFFBOARD) continue;
        if (stone & color) {
          //count(sq, color)
          //if (len(liberties) == 0) clearBlock();
          //restore_board()
        }
      }
    }

    // Search move
    function search(depth) {
      // Loop over the board squares
      for (let sq = 0; sq < size ** 2; sq++) {
        // Skip offboard squares
        if (board[sq] == 7) continue;

        // Generate move
        if (!board[sq]) {
          // Preserve board position
          old_board = JSON.stringify(board);
          
          // Make move
          board[sq] = 1; printBoard(); alert();
          // Search recursively

          // Take back
          board = JSON.parse(old_board); printBoard(); alert();
        }
      }
    }

    // Main
    initBoard();
    //search();
    printPosition();
    drawBoard();
  </script>
</body>
</html>
