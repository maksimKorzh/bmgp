<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BMGP</title>
</head>
<body>
  <canvas
    id="gobang"
    width="500"
    height="500"
    style="
      padding: 0;
      margin: auto;
      display: block;
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;">
  </canvas>
  <script>
    // Init board canvas
    const canvas = document.getElementById('gobang');
    const ctx = canvas.getContext('2d');

    // Go board
    var board = [];

    // 5x5 board, +2 is offboard
    var size = 7;

    // Rendered cell size
    const cell = canvas.width / size;

    // Render stone
    function drawStone(x, y, color) {
    }

    // Print position to console
    function printPosition() {
      let position = "";
      for (let sq = 0; sq < size*size; sq++) {
        position += (!(sq % size)) ? "\n" : "";
        position += board[sq] + " ";
      };console.log(position);
    }

    // Print board
    function drawBoard() {
      ctx.beginPath();
      for (let i = 1; i < size-1; i++) {
        const x = i * cell + cell / 2;
        const y = i * cell + cell / 2;
        let offset = cell * 2 - cell / 2;
        ctx.moveTo(offset, y);
        ctx.lineTo(canvas.width - offset, y);
        ctx.moveTo(x, offset);
        ctx.lineTo(x, canvas.height - offset);
      };ctx.stroke();
      for (let row = 0; row < size; row++) {
        for (let col = 0; col < size; col++) {
          let sq = row*size + col;
          if (board[sq] == 7) continue;
          let color = board[row * size + col] ? "black" : "white";
          if (board[sq]) {
            ctx.beginPath();
            ctx.arc(col * cell + cell / 2, row * cell + cell / 2, cell / 2 - 2, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.stroke();
          }
        }
      }
    }

    // Init board
    function initBoard() {
      for (let sq = 0; sq < size*size; sq++) {
        switch (true) {
          case (sq < size):
          case (sq >= (size*size - size)):
          case (!(sq % size)):
            board[sq] = 7;
            board[sq-1] = 7;
            break;
          default: board[sq] = 0;
        }
      }
    }

    // Search move
    function search(depth) {
      // Loop over the board squares
      for (let sq = 0; sq < size*size; sq++) {
        // Skip offboard squares
        if (board[sq] == 7) continue;

        // Generate move
        if (!board[sq]) {
          // Preserve board position
          old_board = JSON.stringify(board);
          
          // Make move
          board[sq] = 1; printBoard(); alert();
          // Search recursively

          // Take back
          board = JSON.parse(old_board); printBoard(); alert();
        }
      }
    }

    // Main
    initBoard();
    //search();
    printPosition();
    drawBoard();
  </script>
</body>
</html>


