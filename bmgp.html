<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BMGP</title>
</head>
<body>
  <canvas
    id="gobang"
    width="500"
    height="500"
    style="
      padding: 0;
      margin: auto;
      display: block;
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;">
  </canvas>
  <script>
    // Init board canvas
    const canvas = document.getElementById('gobang');
    const ctx = canvas.getContext('2d');

    // Stone encodings
    const EMPTY = 0
    const BLACK = 1
    const WHITE = 2
    const MARKER = 4
    const OFFBOARD = 7
    const LIBERTY = 8

    // Go board
    var board = [];

    // 5x5 board, +2 is offboard
    var size = 7;

    // Side to move
    var side = BLACK;

    // Count liberties & blocks
    var liberties = [];
    var block = [];
    var ko = EMPTY;

    // Rendered cell size
    const cell = canvas.width / size;

    // Print position to console
    function printPosition() {
      let position = "";
      for (let sq = 0; sq < size ** 2; sq++) {
        position += (!(sq % size)) ? "\n" : "";
        position += board[sq] + " ";
      };console.log(position);
    }

    // Print board
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      for (let i = 1; i < size-1; i++) {
        const x = i * cell + cell / 2;
        const y = i * cell + cell / 2;
        let offset = cell * 2 - cell / 2;
        ctx.moveTo(offset, y);
        ctx.lineTo(canvas.width - offset, y);
        ctx.moveTo(x, offset);
        ctx.lineTo(x, canvas.height - offset);
      };ctx.stroke();
      for (let row = 0; row < size; row++) {
        for (let col = 0; col < size; col++) {
          let sq = row*size + col;
          if (board[sq] == 7) continue;
          let color = board[row * size + col] == 1 ? "black" : "white";
          if (board[sq]) {
            ctx.beginPath();
            ctx.arc(col * cell + cell / 2, row * cell + cell / 2, cell / 2 - 2, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.stroke();
          }
        }
      }
    }

    // Handle mouse click event
    canvas.addEventListener('click', function (event) {
      let rect = canvas.getBoundingClientRect();
      let mouseX = event.clientX - rect.left;
      let mouseY = event.clientY - rect.top;
      let col = Math.floor(mouseX / cell);
      let row = Math.floor(mouseY / cell);
      let sq = row * size + col;
      setStone(sq, side);
    });

    // Put stone on board
    function setStone(sq, color) {
      if (board[sq] != EMPTY) {
        alert("Illegal move!");
        return false;
      } else if (sq == ko) {
        alert("Ko!");
        return false;
      }
      let old_ko = ko;
      ko = EMPTY;
      board[sq] = color;
      captures(3 - color);
      count(sq, color);
      let suicide = liberties.length ? false : true; 
      restoreBoard();
      if (suicide) {
        board[sq] = EMPTY;
        ko = old_ko;
        side = 3 - side;
        alert("Suicide move!");
      }
      side = 3 - side;
      drawBoard();
      printPosition();
    }

    // Init board
    function initBoard() {
      for (let sq = 0; sq < size ** 2; sq++) {
        switch (true) {
          case (sq < size):
          case (sq >= (size ** 2 - size)):
          case (!(sq % size)):
            board[sq] = OFFBOARD;
            board[sq-1] = OFFBOARD;
            break;
          default: board[sq] = 0;
        }
      }
    }

    // Handle captures
    function captures(color) {
      for (let sq = 0; sq < size ** 2; sq++) {
        let stone = board[sq];
        if (stone == OFFBOARD) continue;
        if (stone & color) {
          count(sq, color);
          if (liberties.length == 0) clearBlock();
          restoreBoard()
        }
      }
    }

    // Count liberties, save stone group coords
    function count(sq, color) {
      stone = board[sq];
      if (stone == OFFBOARD) return;
      if (stone && (stone & color) && (stone & MARKER) == 0) {
        block.push(sq);
        board[sq] |= MARKER;
        count(sq - size, color);
        count(sq - 1, color);
        count(sq + size, color);
        count(sq + 1, color);
      } else if (stone == EMPTY) {
        board[sq] |= LIBERTY;
        liberties.push(sq);
      }
    }
 
    // Restore the board after counting stones
    function restoreBoard() {
      clearGroups();
      for (let sq = 0; sq < size ** 2; sq++) {
        if (board[sq] != OFFBOARD) board[sq] &= 3;
      }
    }

    // Remove captured stones
    function clearBlock() {
      if (block.length == 1) ko = block[0];
      for (let i = 0; i < block.length; i++)
        board[block[i]] = EMPTY;
    }

    // Clear groups
    function clearGroups() {
      block = [];
      liberties = [];
    }

    // Search move
    function search(depth) {
      // Loop over the board squares
      for (let sq = 0; sq < size ** 2; sq++) {
        // Skip offboard squares
        if (board[sq] == 7) continue;

        // Generate move
        if (!board[sq]) {
          // Preserve board position
          old_board = JSON.stringify(board);
          
          // Make move
          board[sq] = 1; printBoard(); alert();
          // Search recursively

          // Take back
          board = JSON.parse(old_board); printBoard(); alert();
        }
      }
    }

    // Main
    initBoard();
    //search();
    printPosition();
    drawBoard();
  </script>
</body>
</html>
